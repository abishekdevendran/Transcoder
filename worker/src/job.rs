use crate::options::TranscodeOptions;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub const TRANSCODING_JOB_STREAM_KEY: &str = "transcoding_jobs";
pub const JOB_CONSUMER_GROUP: &str = "video_workers_group";

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JobPayload {
    pub job_id: String, // A unique ID for the job itself, can be generated by the producer
    pub input_path: String,
    pub output_path: String,
    pub options: TranscodeOptions,
}

// This structure will hold the message ID from Valkey along with the payload
#[derive(Debug, Clone)]
pub struct Job {
    pub message_id: String,
    pub payload: JobPayload,
}

pub fn parse_job_from_map(message_id: String, fields: HashMap<String, redis::Value>) -> Result<Job, String> {
    let job_id: String = redis::from_redis_value(
        fields.get("job_id").ok_or("Missing job_id field")?
    ).map_err(|e| format!("Failed to parse job_id: {}", e))?;

    let input_path: String = redis::from_redis_value(
        fields.get("input_path").ok_or("Missing input_path field")?
    ).map_err(|e| format!("Failed to parse input_path: {}", e))?;

    let output_path: String = redis::from_redis_value(
        fields.get("output_path").ok_or("Missing output_path field")?
    ).map_err(|e| format!("Failed to parse output_path: {}", e))?;
    
    let options_json_str: String = redis::from_redis_value(
        fields.get("options_json").ok_or("Missing options_json field")?
    ).map_err(|e| format!("Failed to parse options_json string: {}", e))?;

    let options: TranscodeOptions = serde_json::from_str(&options_json_str)
        .map_err(|e| format!("Failed to deserialize TranscodeOptions from JSON: {}", e))?;

    Ok(Job {
        message_id,
        payload: JobPayload {
            job_id,
            input_path,
            output_path,
            options,
        },
    })
}
